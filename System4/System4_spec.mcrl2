sort Cart = struct c1 | c2 | c3 | c4;
sort SwitchState = struct up | middle | down;
sort Refinery = struct r1 | r2 | r3;
sort Section = struct s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9;
%Stores the location of the carts: Nat(indicates which cart) -> Nat(position).
sort LocArray = Nat -> Nat;
%Stores the assigned cart to the refinery: Nat(indicates which cart) -> Cart(the cart assigned to the refinery).
sort RefMap = Nat -> Cart;
%Stores the oustanding requests: Nat(indicates which refinery) -> Bool (false = no request).
sort OutstandingRequests = Nat -> Bool;
%Stores a boolean for each cart whether it is full or broken
sort IsFull = Nat -> Bool;
sort CartsBroken = Nat -> Bool;
%Stores the broken states of the refineries
sort RefBroken = Nat -> Bool;

glob refmap: RefMap;

%Maps the carts to Nat in order to use them in an array (mcrl2 doesn't allow Cart as index).
map getCart: Cart -> Nat;
eqn
	getCart(c1) = 1;
	getCart(c2) = 2;
	getCart(c3) = 3;
	getCart(c4) = 4;

%Maps the refineries to their location.
map getRefLoc: Refinery -> Nat;
eqn
	getRefLoc(r1) = 4;
	getRefLoc(r2) = 6;
	getRefLoc(r3) = 8;

%Maps a switch state to each refinery
map getRefSwitch: Refinery -> SwitchState;
eqn
	getRefSwitch(r1) = up;
	getRefSwitch(r2) = middle;
	getRefSwitch(r3) = down;

%Maps the refineries to Nat in order to use them in an array.
map getRef: Refinery -> Nat;
eqn
	getRef(r1) = 1;
	getRef(r2) = 2;
	getRef(r3) = 3;

map getSection: Section -> Nat;
eqn
	getSection(s1) = 1;
	getSection(s2) = 2;
	getSection(s3) = 3;
	getSection(s4) = 4;
	getSection(s5) = 5;
	getSection(s6) = 6;
	getSection(s7) = 7;
	getSection(s8) = 8;
	getSection(s9) = 9;

map getSecByNat: Nat -> Section;
eqn
	getSecByNat(1) = s1;
	getSecByNat(2) = s2;
	getSecByNat(3) = s3;
	getSecByNat(4) = s4;
	getSecByNat(5) = s5;
	getSecByNat(6) = s6;
	getSecByNat(7) = s7;
	getSecByNat(8) = s8;
	getSecByNat(9) = s9;

map getRefSec: Refinery -> Section;
eqn
	getRefSec(r1) = s4;
	getRefSec(r2) = s6;
	getRefSec(r3) = s8;

map locInit: Nat -> Nat;
eqn
	locInit(1) = 4;
	locInit(2) = 6;
	locInit(3) = 8;
	locInit(4) = 0;

map refInit: Nat -> Cart;
eqn
	refInit(1) = c1;
	refInit(2) = c2;
	refInit(3) = c3;

map reqsInit: Nat -> Bool;
eqn
	reqsInit(1) = false;
	reqsInit(2) = false;
	reqsInit(3) = false;

map fullInit: Nat -> Bool;
eqn
	fullInit(1) = false;
	fullInit(2) = false;
	fullInit(3) = false;
	fullInit(4) = false;

map cartbrokenInit: Nat -> Bool;
eqn
	cartbrokenInit(1) = false;
	cartbrokenInit(2) = false;
	cartbrokenInit(3) = false;
	cartbrokenInit(4) = false;

map refbrokenInit: Nat -> Bool;
eqn
	refbrokenInit(1) = false;
	refbrokenInit(2) = false;
	refbrokenInit(3) = false;

act
	%Requests between controller and cartcontroller
	s_request, r_request, request_load: Cart # Refinery;
	s_empty, r_empty, receive_load: Cart # Refinery;
	
	%Furnace unloading
	s_fill, r_fill, furnace_unload; 

	%Breaking of furnace
	r_furnace_broken, s_furnace_broken, furnace_broken, r_furnace_fixed, s_furnace_fixed, furnace_fixed;
	
	%Breaking of refinery
	r_ref_broken, s_ref_broken, refinery_broken, r_ref_fixed, s_ref_fixed, refinery_fixed: Refinery;

	%Moving carts
	s_move_to, r_move_to, move_to: Cart # Section;

	%Breaking of carts
	r_cart_broken, s_cart_broken, cart_broken, r_cart_fixed, s_cart_fixed, cart_fixed, cart_empty_on_spot: Cart;

	%Breaking of switch
	s_switch_broken, r_switch_broken, switch_broken, r_switch_fixed, s_switch_fixed, switch_fixed;

	%Switch changes
	change_switch_state: SwitchState;

	%Section occupied or free
	section_occupied, section_free: Section;

	%Communicating refmap changes
	r_refmap_changed, s_refmap_changed, cart_reassigned: Refinery # Cart;

proc
	IronController(rm: RefMap, reqs: OutstandingRequests, furBroken: Bool, refBroken: RefBroken) = 
				%Receive requests or empty carts (to finish requests)
				(sum c:Cart, r:Refinery . (rm(getRef(r)) == c) -> 
					(reqs(getRef(r)) -> s_empty(c,r).IronController(rm, reqs[getRef(r)->false], furBroken, refBroken))) +
				(sum c:Cart, r:Refinery . ((rm(getRef(r)) == c) && !reqs(getRef(r)) && !refBroken(getRef(r))) -> 
						r_request(c,r).IronController(rm, reqs[getRef(r)->true], furBroken, refBroken)) +
				%Fill carts with iron
				((!furBroken) -> 
					s_fill.IronController(rm, reqs, furBroken, refBroken)) +
				%Furnace breaking and fixing
				((!furBroken) ->
					r_furnace_broken.IronController(rm, reqs, true, refBroken)) +
				(s_furnace_fixed.IronController(rm, reqs, false, refBroken)) +
				%Refinery breaking and fixing
				(sum r:Refinery . (!refBroken(getRef(r)) ->
					r_ref_broken(r).IronController(rm, reqs, furBroken, refBroken[getRef(r)->true]))) +
				(sum r:Refinery . s_ref_fixed(r) . IronController(rm, reqs, furBroken, refBroken[getRef(r)->false])) + 
				(sum c:Cart, r:Refinery . s_refmap_changed(r,c) . IronController(rm[getRef(r) -> c], reqs, furBroken, refBroken)) +
				%Cart moving
				(sum c:Cart, s:Section . s_move_to(c, s) . IronController(rm, reqs, furBroken, refBroken));
				
	
	Repair(refBroken:RefBroken, furBroken:Bool, cartsBroken:CartsBroken) = 
				(sum r:Refinery . (!refBroken(getRef(r)) -> s_ref_broken(r) . Repair(refBroken[getRef(r)->true], furBroken, cartsBroken))) +
				(sum c:Cart . (!cartsBroken(getCart(c)) -> s_cart_broken(c) . Repair(refBroken, furBroken, cartsBroken[getCart(c)->true]))) +
				((!furBroken -> s_furnace_broken . Repair(refBroken, true, cartsBroken))) +
				(sum r:Refinery . (refBroken(getRef(r)) -> r_ref_fixed(r) . Repair(refBroken[getRef(r)->false], furBroken, cartsBroken))) +
				(sum c:Cart . (cartsBroken(getCart(c)) -> r_cart_fixed(c) . Repair(refBroken, furBroken, cartsBroken[getCart(c)->false]))) +
				((furBroken -> r_furnace_fixed . Repair(refBroken, false, cartsBroken)));

	CartControl(locs:LocArray, rm:RefMap, reqs:OutstandingRequests, full:IsFull, swstate:SwitchState, swbroken:Bool, cartsbroken:CartsBroken) =
				%Cars breaking and possibly changing refinery cart mapping
				(sum c:Cart . ( !cartsbroken(getCart(c)) -> 
					(r_cart_broken(c) . ( full(getCart(c)) -> cart_empty_on_spot(c) <> tau ) .
					(exists s:Refinery . rm(getRef(s)) == c) -> (sum r:Refinery . ( rm(getRef(r)) == c && reqs(getRef(r)) ) ->
						(exists d: Cart . ( !cartsbroken(getCart(d)) && !(rm(getRef(r1)) == d || rm(getRef(r2)) == d || rm(getRef(r3)) == d) && c != d )) -> (
						((sum d:Cart . ( !cartsbroken(getCart(d)) && !(rm(getRef(r1)) == d || rm(getRef(r2)) == d || rm(getRef(r3)) == d) && c != d ) ->
							r_refmap_changed(r, d) . CartControl(locs, rm[getRef(r)->d], reqs, full[getCart(c)->false], swstate, swbroken, cartsbroken[getCart(c)->true])
						))) <>
							CartControl(locs, rm, reqs, full[getCart(c)->false], swstate, swbroken, cartsbroken[getCart(c)->true])
					<>
						(rm(getRef(r)) == c ) -> CartControl(locs, rm, reqs, full[getCart(c)->false], swstate, swbroken, cartsbroken[getCart(c)->true]))
					<>
						CartControl(locs, rm, reqs, full[getCart(c)->false], swstate, swbroken, cartsbroken[getCart(c)->true])))) + 

				%(exists r:Refinery . rm(getRef(r)) == c && reqs(getRef(r))) -> 
				%	(exists d:Cart . !cartsbroken(getCart(d)) && (!exists s:Refinery . rm(getRef(s)) == d)) ->
				%		r_refmap_changed(d, r) . CartControl(locs, rm[getRef(r)->d], reqs, full[getCart(c)->false], swstate, swbroken, cartsbroken[getCart(c)->true])
				%	<>
				%		CartControl(locs, rm, reqs, full[getCart(c)->false], swstate, swbroken, cartsbroken[getCart(c)->true])
				%<> 
				%	CartControl(locs, rm, reqs, full[getCart(c)->false], swstate, swbroken, cartsbroken[getCart(c)->true])) +

				%Cart fixing
				(sum c:Cart . s_cart_fixed(c) . CartControl(locs, rm, reqs, full, swstate, swbroken, cartsbroken[getCart(c)->false])) +
				%Switch breaking and fixing
				(!swbroken -> r_switch_broken . CartControl(locs, rm, reqs, full, swstate, true, cartsbroken)) +
				(s_switch_fixed . CartControl(locs, rm, reqs, full, swstate, false, cartsbroken)) +
				%Request acceptance
				(sum c:Cart, r:Refinery . s_request(c, r) . CartControl(locs, rm, reqs[getRef(r)->true], full, swstate, swbroken, cartsbroken)) +
				
				%Car movement
				(sum c:Cart, r:Refinery . ( reqs(getRef(r)) && rm(getRef(r)) == c && !cartsbroken(getCart(c))) ->
					( full(getCart(c)) ->
						( (locs(getCart(c)) == getRefLoc(r)) ->
							( r_empty(c, r) . CartControl(locs, rm, reqs[getRef(r)->false], full[getCart(c)->false], swstate, swbroken, cartsbroken) ) 
						<>
							( (locs(getCart(c)) == 2) -> 
								( ((swstate != getRefSwitch(r)) && !swbroken) -> 
									change_switch_state(getRefSwitch(r)) . CartControl(locs, rm, reqs, full, getRefSwitch(r), swbroken, cartsbroken) 
								<> 
									( (!(exists d:Cart . locs(getCart(d)) == 3) && !swbroken) ->
										section_free(s3) . r_move_to(c, s3) . section_occupied(s3) . CartControl(locs[getCart(c)->3], rm, reqs, full, swstate, swbroken, cartsbroken)
									)
								)
							<>
								( ((locs(getCart(c)) == 3) && !swbroken) ->
									( !(exists d:Cart . locs(getCart(d)) == getRefLoc(r)) ->
										section_free(getSecByNat(getRefLoc(r))) . r_move_to(c, getRefSec(r)) . section_occupied(getSecByNat(getRefLoc(r))) . CartControl(locs[getCart(c)->getRefLoc(r)], rm, reqs, full, swstate, swbroken, cartsbroken)
									)
								)
							) 
						) 
					<>
						( (locs(getCart(c)) == getRefLoc(r)) ->
							( (!swbroken && !(exists d:Cart . locs(getCart(d)) == 3 || locs(getCart(d)) == 2)) ->
								( (swstate != getRefSwitch(r)) -> 
									change_switch_state(getRefSwitch(r)) . section_free(s3) . r_move_to(c, s3) . section_occupied(s3) . CartControl(locs[getCart(c)->3], rm, reqs, full, getRefSwitch(r), swbroken, cartsbroken) 
								<>
									section_free(s3) . r_move_to(c, s3) . section_occupied(s3) . CartControl(locs[getCart(c)->3], rm, reqs, full, swstate, swbroken, cartsbroken)
								)
							)
						<>
							( (locs(getCart(c)) == 3) -> 
								( (!(exists d:Cart . locs(getCart(d)) == 2) && !swbroken) ->
									section_free(s2) . r_move_to(c, s2) . section_occupied(s2) . CartControl(locs[getCart(c)->2], rm, reqs, full, swstate, swbroken, cartsbroken)
								)
							<>
								( (locs(getCart(c)) == 2) ->
									r_fill . CartControl(locs, rm, reqs, full[getCart(c)->true], swstate, swbroken, cartsbroken)
								)
							)
						)
					)
				);

init 
	allow(
		{request_load, receive_load, furnace_unload, furnace_broken, furnace_fixed, refinery_broken, refinery_fixed, cart_broken, cart_fixed, cart_empty_on_spot, switch_broken, switch_fixed, cart_reassigned, change_switch_state, move_to, section_free, section_occupied},
		comm(
			{r_request|s_request -> request_load,
			 r_empty|s_empty -> receive_load,
			 r_fill|s_fill -> furnace_unload,
			 r_furnace_broken|s_furnace_broken -> furnace_broken,
			 r_furnace_fixed|s_furnace_fixed -> furnace_fixed,
			 r_ref_broken|s_ref_broken -> refinery_broken,
			 r_ref_fixed|s_ref_fixed -> refinery_fixed,
			 r_move_to|s_move_to -> move_to,
			 r_cart_broken|s_cart_broken -> cart_broken,
			 r_cart_fixed|s_cart_fixed -> cart_fixed,
			 r_switch_broken|s_switch_broken -> switch_broken,
			 r_switch_fixed|s_switch_fixed -> switch_fixed,
			 r_refmap_changed|s_refmap_changed -> cart_reassigned},
		CartControl(locInit, refInit, reqsInit, fullInit, middle, false, cartbrokenInit) || IronController(refInit, reqsInit, false, refbrokenInit) || Repair(refbrokenInit, false, cartbrokenInit)
	));

