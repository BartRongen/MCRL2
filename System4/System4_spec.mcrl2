sort Cart = struct c1 | c2 | c3 | c4;
sort SwitchState = struct up | middle | down;
sort Refinery = struct r1 | r2 | r3;
sort Section = struct s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9;
%Stores the location of the carts: Nat(indicates which cart) -> Nat(position).
sort LocArray = Nat -> Nat;
%Stores the assigned cart to the refinery: Nat(indicates which cart) -> Cart(the cart assigned to the refinery).
sort RefMap = Nat -> Cart;
%Stores the oustanding requests: Nat(indicates which refinery) -> Bool (false = no request).
sort OutstandingRequests = Nat -> Bool;
%Stores a boolean for each cart whether it is full or broken
sort IsFull = Nat -> Bool;
sort CartsBroken = Nat -> Bool;
%Stores the broken states of the refineries
sort RefBroken = Nat -> Bool;

glob refmap: RefMap;

%Maps the carts to Nat in order to use them in an array (mcrl2 doesn't allow Cart as index).
map getCart: Cart -> Nat;
eqn
	getCart(c1) = 1;
	getCart(c2) = 2;
	getCart(c3) = 3;
	getCart(c4) = 4;

%Maps the refineries to their location.
map getRefLoc: Refinery -> Nat;
eqn
	getRefLoc(r1) = 4;
	getRefLoc(r2) = 6;
	getRefLoc(r3) = 8;

%Maps the refineries to Nat in order to use them in an array.
map getRef: Refinery -> Nat;
eqn
	getRef(r1) = 1;
	getRef(r2) = 2;
	getRef(r3) = 3;

map getSection: Section -> Nat;
eqn
	getSection(s1) = 1;
	getSection(s2) = 2;
	getSection(s3) = 3;
	getSection(s4) = 4;
	getSection(s5) = 5;
	getSection(s6) = 6;
	getSection(s7) = 7;
	getSection(s8) = 8;
	getSection(s9) = 9;

map locInit: Nat -> Nat;
eqn
	locInit(1) = 4;
	locInit(2) = 6;
	locInit(3) = 8;
	locInit(4) = 0;

map refInit: Nat -> Cart;
eqn
	refInit(1) = c1;
	refInit(2) = c2;
	refInit(3) = c3;

map reqsInit: Nat -> Bool;
eqn
	reqsInit(1) = false;
	reqsInit(2) = false;
	reqsInit(3) = false;

map fullInit: Nat -> Bool;
eqn
	fullInit(1) = false;
	fullInit(2) = false;
	fullInit(3) = false;
	fullInit(4) = false;

map cartbrokenInit: Nat -> Bool;
eqn
	cartbrokenInit(1) = false;
	cartbrokenInit(2) = false;
	cartbrokenInit(3) = false;
	cartbrokenInit(4) = false;

map refbrokenInit: Nat -> Bool;
eqn
	refbrokenInit(1) = false;
	refbrokenInit(2) = false;
	refbrokenInit(3) = false;

act
	%Requests between controller and cartcontroller
	s_request, r_request, request: Cart # Refinery;
	s_empty, r_empty, receive_load: Cart # Refinery;
	
	%Furnace unloading
	s_fill, r_fill, furnace_unload; 

	%Breaking of furnace
	r_furnace_broken, s_furnace_broken, furnace_broken, r_furnace_fixed, s_furnace_fixed, furnace_fixed;
	
	%Breaking of refinery
	r_ref_broken, s_ref_broken, refinery_broken, r_ref_fixed, s_ref_fixed, refinery_fixed: Refinery;
	s_move_to, r_move_to, move_to: Cart # Section;

	%Breaking of carts
	r_cart_broken, s_cart_broken, cart_broken, r_cart_fixed, s_cart_fixed, cart_fixed, cart_empty_on_spot: Cart;

	%Breaking of switch
	s_switch_broken, r_switch_broken, switch_broken, r_switch_fixed, s_switch_fixed, switch_fixed;

	%Communicating refmap changes
	r_refmap_changed, s_refmap_changed, refmap_changed: Refinery # Cart;

proc
	IronController(rm: RefMap, reqs: OutstandingRequests, furBroken: Bool, refBroken: RefBroken) = 
				%Receive requests or empty carts (to finish requests)
				(sum c:Cart, r:Refinery . (rm(getRef(r)) == c) -> 
					(reqs(getRef(r)) -> s_empty(c,r).IronController(rm, reqs[getRef(r)->false], furBroken, refBroken))) +
				(sum c:Cart, r:Refinery . ((rm(getRef(r)) == c) && !reqs(getRef(r)) && !refBroken(getRef(r))) -> 
						r_request(c,r).IronController(rm, reqs[getRef(r)->true], furBroken, refBroken)) +
				%Fill carts with iron
				((!furBroken) -> 
					s_fill.IronController(rm, reqs, furBroken, refBroken)) +
				%Furnace breaking and fixing
				((!furBroken) ->
					r_furnace_broken.IronController(rm, reqs, true, refBroken)) +
				(s_furnace_fixed.IronController(rm, reqs, false, refBroken)) +
				%Refinery breaking and fixing
				(sum r:Refinery . (!refBroken(getRef(r)) ->
					r_ref_broken(r).IronController(rm, reqs, furBroken, refBroken[getRef(r)->true]))) +
				(sum r:Refinery . s_ref_fixed(r) . IronController(rm, reqs, furBroken, refBroken[getRef(r)->false]));
				
	
	Repair = (sum r:Refinery . s_ref_broken(r) . r_ref_fixed(r) . Repair) + 
			 (sum c:Cart . s_cart_broken(c) . r_cart_fixed(c) . Repair) +
			 (s_furnace_broken . r_furnace_fixed . Repair) +
			 (s_switch_broken . r_switch_fixed . Repair);

	CartControl(locs:LocArray, rm:RefMap, reqs:OutstandingRequests, full:IsFull, swstate:SwitchState, swbroken:Bool, cartsbroken:CartsBroken) =
				%Cars breaking and possibly changing refinery cart mapping
				(sum c:Cart . !cartsbroken(getCart(c)) -> r_cart_broken(c) . (full(getCart(c)) -> cart_empty_on_spot(c)) . 
				(exists r:Refinery . rm(getRef(r)) == c && reqs(getRef(r))) -> 
					(exists d:Cart . !cartsbroken(getCart(d)) && (!exists s:Refinery . rm(getRef(s)) == d)) ->
						r_refmap_changed(d, r) . CartControl(locs, rm[getRef(r)->d], reqs, full[getCart(c)->false], swstate, swbroken, cartsbroken[getCart(c)->true])
					<>
						CartControl(locs, rm, reqs, full[getCart(c)->false], swstate, swbroken, cartsbroken[getCart(c)->true])
				<> 
					CartControl(locs, rm, reqs, full[getCart(c)->false], swstate, swbroken, cartsbroken[getCart(c)->true])) +
				%Cart fixing
				(sum c:Cart . s_cart_fixed(c) . CartControl(locs, rm, reqs, full, swstate, swbroken, cartsbroken[getCart(c)->false])) +
				%Switch breaking and fixing
				(!swbroken -> r_switch_broken . CartControl(locs, rm, reqs, full, swstate, true, cartsbroken)) +
				(s_switch_fixed . CartControl(locs, rm, reqs, full, swstate, false, cartsbroken));
				%Cart moving

init 
	allow(
		{request, furnace_unload, receive_load, broken, repaired, move_to, section_occupied, section_free},
		comm(
			{s_request|r_request -> request, 
			 s_fill|r_fill -> furnace_unload, 
			 s_empty|r_empty -> receive_load, cartbroken|r_broken -> broken,
			 s_repair|cartfixed -> repaired},
		CartControl(locsInit, refInit, reqsInit, fullInit, middle, false, cartbrokenInit) || IronController(refInit, reqsInit, false, refbrokenInit) || Repair
	));

